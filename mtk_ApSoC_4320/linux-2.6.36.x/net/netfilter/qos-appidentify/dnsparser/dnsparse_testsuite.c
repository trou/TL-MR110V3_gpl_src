/*!Copyright(c) 2008-2013 Shenzhen TP-LINK Technologies Co.Ltd.
 *
 *\file        dnsparse.c
 *\brief
 *
 *\author      wangquzhi
 *\version
 *\date        2013/02/04
 *
 *\history     2013/02/04, created this file, wangquzhi
 *
 *
 */


/**************************************************************************************************/
/*                                      CONFIGURATIONS                                            */
/**************************************************************************************************/

/**************************************************************************************************/
/*                                      INCLUDE_FILES                                             */
/**************************************************************************************************/
#include <linux/kernel.h>
#include <linux/mempool.h>
#include <linux/types.h>
#include <linux/list.h>

#include "dnsparse_typedef.h"
#include "dnsparse_api.h"
#include "dnsparse_testsuite.h"
/**************************************************************************************************/
/*                                      DEFINES                                                   */
/**************************************************************************************************/

/**************************************************************************************************/
/*                                      TYPES                                                     */
/**************************************************************************************************/

/**************************************************************************************************/
/*                                      EXTERN_PROTOTYPES                                         */
/**************************************************************************************************/

/**************************************************************************************************/
/*                                      LOCAL_PROTOTYPES                                          */
/**************************************************************************************************/

/**************************************************************************************************/
/*                                      VARIABLES                                                 */
/**************************************************************************************************/
DNSPARSE_DNS_MESSAGE testmsg;

const char DNSPARSE_TESTDATA_QUERY_0[] = {
0xdb, 0xd0, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x04, 0x73, 0x74, 0x61,
0x74, 0x07, 0x33, 0x36, 0x30, 0x73, 0x61, 0x66,
0x65, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01,
0x00, 0x01 };
const char DNSPARSE_TESTDATA_ANSWER_0[] = {
0xdb, 0xd0, 0x81, 0x80, 0x00, 0x01, 0x00, 0x07,
0x00, 0x06, 0x00, 0x09, 0x04, 0x73, 0x74, 0x61,
0x74, 0x07, 0x33, 0x36, 0x30, 0x73, 0x61, 0x66,
0x65, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01,
0x00, 0x01, 0xc0, 0x0c, 0x00, 0x05, 0x00, 0x01,
0x00, 0x00, 0x03, 0x6f, 0x00, 0x05, 0x02, 0x67,
0x33, 0xc0, 0x0c, 0xc0, 0x2e, 0x00, 0x05, 0x00,
0x01, 0x00, 0x00, 0x03, 0x70, 0x00, 0x07, 0x04,
0x67, 0x33, 0x2d, 0x73, 0xc0, 0x0c, 0xc0, 0x3f,
0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x03, 0x70,
0x00, 0x04, 0xdd, 0xcc, 0xcb, 0x52, 0xc0, 0x3f,
0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x03, 0x70,
0x00, 0x04, 0x77, 0xbc, 0x0f, 0xf1, 0xc0, 0x3f,
0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x03, 0x70,
0x00, 0x04, 0x77, 0xbc, 0x0f, 0xf2, 0xc0, 0x3f,
0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x03, 0x70,
0x00, 0x04, 0xdd, 0xcc, 0xcb, 0x4b, 0xc0, 0x3f,
0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x03, 0x70,
0x00, 0x04, 0xdd, 0xcc, 0xcb, 0x4c, 0xc0, 0x11,
0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x0b, 0xbe,
0x00, 0x06, 0x03, 0x6e, 0x73, 0x36, 0xc0, 0x11,
0xc0, 0x11, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00,
0x0b, 0xbe, 0x00, 0x06, 0x03, 0x6e, 0x73, 0x34,
0xc0, 0x11, 0xc0, 0x11, 0x00, 0x02, 0x00, 0x01,
0x00, 0x00, 0x0b, 0xbe, 0x00, 0x06, 0x03, 0x6e,
0x73, 0x38, 0xc0, 0x11, 0xc0, 0x11, 0x00, 0x02,
0x00, 0x01, 0x00, 0x00, 0x0b, 0xbe, 0x00, 0x06,
0x03, 0x6e, 0x73, 0x37, 0xc0, 0x11, 0xc0, 0x11,
0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x0b, 0xbe,
0x00, 0x06, 0x03, 0x6e, 0x73, 0x33, 0xc0, 0x11,
0xc0, 0x11, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00,
0x0b, 0xbe, 0x00, 0x06, 0x03, 0x6e, 0x73, 0x35,
0xc0, 0x11, 0xc0, 0xea, 0x00, 0x01, 0x00, 0x01,
0x00, 0x00, 0x0e, 0x45, 0x00, 0x04, 0xdc, 0xb5,
0x7f, 0xac, 0xc0, 0xea, 0x00, 0x01, 0x00, 0x01,
0x00, 0x00, 0x0e, 0x45, 0x00, 0x04, 0x71, 0x69,
0xf6, 0x2e, 0xc0, 0xea, 0x00, 0x01, 0x00, 0x01,
0x00, 0x00, 0x0e, 0x45, 0x00, 0x04, 0x7c, 0xee,
0xf4, 0x5c, 0xc0, 0xb4, 0x00, 0x01, 0x00, 0x01,
0x00, 0x00, 0x02, 0x31, 0x00, 0x04, 0xda, 0x1e,
0x75, 0x0a, 0xc0, 0xfc, 0x00, 0x01, 0x00, 0x01,
0x00, 0x01, 0x18, 0x33, 0x00, 0x04, 0x3d, 0x37,
0xb8, 0x0a, 0xc0, 0xa2, 0x00, 0x01, 0x00, 0x01,
0x00, 0x00, 0x0e, 0xf6, 0x00, 0x04, 0xdd, 0xc2,
0x86, 0xde, 0xc0, 0xa2, 0x00, 0x01, 0x00, 0x01,
0x00, 0x00, 0x0e, 0xf6, 0x00, 0x04, 0xdd, 0xcc,
0xcb, 0x3e, 0xc0, 0xd8, 0x00, 0x01, 0x00, 0x01,
0x00, 0x00, 0x02, 0x91, 0x00, 0x04, 0x77, 0xbc,
0x43, 0x0a, 0xc0, 0xc6, 0x00, 0x01, 0x00, 0x01,
0x00, 0x00, 0x02, 0x31, 0x00, 0x04, 0xab, 0x08,
0xa7, 0x0a };

const char DNSPARSE_TESTDATA_ANSWER_1[] =
{
0xa6, 0xe4, 0x81, 0x80, 0x00, 0x01, 0x00, 0x03,
0x00, 0x05, 0x00, 0x0b, 0x02, 0x71, 0x64, 0x04,
0x63, 0x6f, 0x64, 0x65, 0x03, 0x33, 0x36, 0x30,
0x02, 0x63, 0x6e, 0x00, 0x00, 0x01, 0x00, 0x01,
0xc0, 0x0c, 0x00, 0x05, 0x00, 0x01, 0x00, 0x00,
0x02, 0x0d, 0x00, 0x13, 0x02, 0x71, 0x64, 0x04,
0x63, 0x6f, 0x64, 0x65, 0x05, 0x71, 0x69, 0x68,
0x6f, 0x6f, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0xc0,
0x2c, 0x00, 0x05, 0x00, 0x01, 0x00, 0x00, 0x02,
0x0d, 0x00, 0x07, 0x04, 0x71, 0x64, 0x2d, 0x73,
0xc0, 0x2f, 0xc0, 0x4b, 0x00, 0x01, 0x00, 0x01,
0x00, 0x00, 0x02, 0x0d, 0x00, 0x04, 0x7b, 0x7d,
0x52, 0xdd, 0xc0, 0x34, 0x00, 0x02, 0x00, 0x01,
0x00, 0x00, 0x0d, 0x14, 0x00, 0x0e, 0x03, 0x6e,
0x73, 0x34, 0x07, 0x33, 0x36, 0x30, 0x73, 0x61,
0x66, 0x65, 0xc0, 0x3a, 0xc0, 0x34, 0x00, 0x02,
0x00, 0x01, 0x00, 0x00, 0x0d, 0x14, 0x00, 0x06,
0x03, 0x6e, 0x73, 0x32, 0xc0, 0x72, 0xc0, 0x34,
0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x0d, 0x14,
0x00, 0x06, 0x03, 0x6e, 0x73, 0x36, 0xc0, 0x72,
0xc0, 0x34, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00,
0x0d, 0x14, 0x00, 0x06, 0x03, 0x6e, 0x73, 0x31,
0xc0, 0x72, 0xc0, 0x34, 0x00, 0x02, 0x00, 0x01,
0x00, 0x00, 0x0d, 0x14, 0x00, 0x06, 0x03, 0x6e,
0x73, 0x33, 0xc0, 0x72, 0xc0, 0xac, 0x00, 0x01,
0x00, 0x01, 0x00, 0x00, 0x03, 0x6e, 0x00, 0x04,
0x7c, 0xee, 0xf4, 0x5b, 0xc0, 0xac, 0x00, 0x01,
0x00, 0x01, 0x00, 0x00, 0x03, 0x6e, 0x00, 0x04,
0xdc, 0xb5, 0x7f, 0xab, 0xc0, 0xac, 0x00, 0x01,
0x00, 0x01, 0x00, 0x00, 0x03, 0x6e, 0x00, 0x04,
0x71, 0x69, 0xf6, 0x2d, 0xc0, 0x88, 0x00, 0x01,
0x00, 0x01, 0x00, 0x00, 0x03, 0x6e, 0x00, 0x04,
0xdd, 0xc2, 0x86, 0xdd, 0xc0, 0x88, 0x00, 0x01,
0x00, 0x01, 0x00, 0x00, 0x03, 0x6e, 0x00, 0x04,
0xdd, 0xcc, 0xcb, 0x3d, 0xc0, 0xbe, 0x00, 0x01,
0x00, 0x01, 0x00, 0x00, 0x0e, 0x45, 0x00, 0x04,
0x7c, 0xee, 0xf4, 0x5c, 0xc0, 0xbe, 0x00, 0x01,
0x00, 0x01, 0x00, 0x00, 0x0e, 0x45, 0x00, 0x04,
0xdc, 0xb5, 0x7f, 0xac, 0xc0, 0xbe, 0x00, 0x01,
0x00, 0x01, 0x00, 0x00, 0x0e, 0x45, 0x00, 0x04,
0x71, 0x69, 0xf6, 0x2e, 0xc0, 0x6e, 0x00, 0x01,
0x00, 0x01, 0x00, 0x00, 0x02, 0x31, 0x00, 0x04,
0xda, 0x1e, 0x75, 0x0a, 0xc0, 0x9a, 0x00, 0x01,
0x00, 0x01, 0x00, 0x00, 0x0e, 0xf6, 0x00, 0x04,
0xdd, 0xc2, 0x86, 0xde, 0xc0, 0x9a, 0x00, 0x01,
0x00, 0x01, 0x00, 0x00, 0x0e, 0xf6, 0x00, 0x04,
0xdd, 0xcc, 0xcb, 0x3e };

char peer1_0[] = {
0x09, 0xc1, 0x81, 0x80, 0x00, 0x01, 0x00, 0x03,
0x00, 0x03, 0x00, 0x03, 0x04, 0x73, 0x64, 0x75,
0x70, 0x03, 0x33, 0x36, 0x30, 0x02, 0x63, 0x6e,
0x00, 0x00, 0x01, 0x00, 0x01, 0xc0, 0x0c, 0x00,
0x05, 0x00, 0x01, 0x00, 0x00, 0x00, 0x93, 0x00,
0x10, 0x04, 0x73, 0x64, 0x75, 0x70, 0x05, 0x71,
0x68, 0x63, 0x64, 0x6e, 0x03, 0x63, 0x6f, 0x6d,
0x00, 0xc0, 0x29, 0x00, 0x01, 0x00, 0x01, 0x00,
0x00, 0x00, 0x2b, 0x00, 0x04, 0x65, 0xe2, 0xa7,
0x12, 0xc0, 0x29, 0x00, 0x01, 0x00, 0x01, 0x00,
0x00, 0x00, 0x2b, 0x00, 0x04, 0x7d, 0x59, 0x49,
0x46, 0xc0, 0x2e, 0x00, 0x02, 0x00, 0x01, 0x00,
0x00, 0x31, 0x8d, 0x00, 0x06, 0x03, 0x6e, 0x73,
0x33, 0xc0, 0x2e, 0xc0, 0x2e, 0x00, 0x02, 0x00,
0x01, 0x00, 0x00, 0x31, 0x8d, 0x00, 0x06, 0x03,
0x6e, 0x73, 0x32, 0xc0, 0x2e, 0xc0, 0x2e, 0x00,
0x02, 0x00, 0x01, 0x00, 0x00, 0x31, 0x8d, 0x00,
0x06, 0x03, 0x6e, 0x73, 0x31, 0xc0, 0x2e, 0xc0,
0x89, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01,
0x4f, 0x00, 0x04, 0x7b, 0x7d, 0x52, 0x1e, 0xc0,
0x77, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x0a,
0x0c, 0x00, 0x04, 0xb4, 0x99, 0xe8, 0x1e, 0xc0,
0x65, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x0a,
0x86, 0x00, 0x04, 0x36, 0xe5, 0x42, 0x6e };
/**************************************************************************************************/
/*                                      LOCAL FUNCTIONS                                           */
/**************************************************************************************************/

/**************************************************************************************************/
/*                                      PUBLIC FUNCTIONS                                          */
/**************************************************************************************************/
IP_PUBLIC void
dnsparse_test_hexdump(Ip_u8 *pData, int size)
{
    int i      = 0;
    int offset = 0;
    int cnt    = size;
    int run    = 0;
    Ip_u8 *data = pData;

    while (cnt) {
//      printk ("%08x : ", offset + pData);
        if (cnt >= 16)
            run = 16;
        else
            run = cnt;
        cnt -= run;
        for (i = 0; i < run; i++)
            printk ("%02X ", (unsigned int)data[i]);
        printk ("| ");
        for (i = 0; i < run; i++)
        {
            if (data[i] >= 32 && data[i] < 127)
            {
                printk ("%c", data[i]);
            }
            else if (data[i] == 0)
            {
                printk("&");
            }
            else
            {
                printk("*");
            }
        }
        printk("\r\n");
        data = &data[16];
        offset += run;
    }
}


IP_PUBLIC void
dnsparse_test_printQuestion(DNSPARSE_DNS_MESSAGE *pMsg)
{
    struct list_head *pListNode = NULL;
    struct list_head *pListHead = NULL;
    int questionCount = 0;

    pListHead = &(pMsg->sections[DNSPARSE_DNS_SECTION_QUESTION]);
    list_for_each(pListNode, pListHead)
    {
        questionCount++;
        printk("QU%2d:", questionCount);
//      printk("%s,0x%08x\r\n", ((DNSPARSE_RR_TYPE *)pListNode)->name,
//                               ((DNSPARSE_RR_TYPE *)pListNode)->name);
    }
}

IP_PUBLIC void
dnsparse_test_printSection(DNSPARSE_DNS_MESSAGE *pMsg, int sectionId)
{
    struct list_head *pListNode = NULL;
    struct list_head *pListHead = NULL;
    int sectionCount = 0;
    char *sectionLable[] = {"NULL", "AN", "AU", "AD"};

    pListHead = &(pMsg->sections[sectionId]);
    list_for_each(pListNode, pListHead)
    {
        sectionCount++;
        printk("%s%2d:", sectionLable[sectionId], sectionCount);
  //    printk("0x%08x,%s ", ((DNSPARSE_RR_TYPE *)pListNode)->name,
  //                         ((DNSPARSE_RR_TYPE *)pListNode)->name);
        /* print type */
        if (((DNSPARSE_RR_TYPE *)pListNode)->type == DNSPARSE_DNS_RR_TYPE_A)
        {
            printk("A ");
        }
        else if (((DNSPARSE_RR_TYPE *)pListNode)->type == DNSPARSE_DNS_RR_TYPE_CNAME)
        {
            printk("CNAME ");
        }
        else
        {
            printk("NOTSUPPORTED ");
        }
        /* print class */
        if (((DNSPARSE_RR_TYPE *)pListNode)->klass == DNSPARSE_DNS_RR_CLASS_IN)
        {
            printk("IN ");
        }
        else
        {
            printk("NOTSUPPORTED ");
        }

        /* print ttl */
        printk("TTL 0x%04x ", ((DNSPARSE_RR_TYPE *)pListNode)->ttl);

        /* print rdata */
        if (((DNSPARSE_RR_TYPE *)pListNode)->type == DNSPARSE_DNS_RR_CLASS_IN)
        {
            printk("%d.%d.%d.%d", ((Ip_u8 *)(((DNSPARSE_RR_TYPE *)pListNode)->pRData))[0],
                                  ((Ip_u8 *)(((DNSPARSE_RR_TYPE *)pListNode)->pRData))[1],
                                  ((Ip_u8 *)(((DNSPARSE_RR_TYPE *)pListNode)->pRData))[2],
                                  ((Ip_u8 *)(((DNSPARSE_RR_TYPE *)pListNode)->pRData))[3]);
        }
        else if (((DNSPARSE_RR_TYPE *)pListNode)->type == DNSPARSE_DNS_RR_TYPE_CNAME)
        {
            //printk("%s", ((DNSPARSE_RR_TYPE *)pListNode)->pRData);
        }

        printk("\r\n");
    }
}

#if 0
IP_PUBLIC void
dnsparse_test_poolStatus()
{
    printk("========   POOL STATUS ========"IP_LF);
    printk("DNSPARSE_NAME_MEMPOOL>"IP_LF);
    printk("TOTAL: %3d USED: %3d SIZE: %d"IP_LF, g_dnsparse_name_mempool->total,
                g_dnsparse_name_mempool->total - g_dnsparse_name_mempool->list.count,
                                                 g_dnsparse_name_mempool->size);
    printk("-------------------------------"IP_LF);
    printk("DNSPARSE_ADDR4_MEMPOOL>"IP_LF);
    printk("TOTAL: %3d USED: %3d SIZE: %d"IP_LF, g_dnsparse_addr4_mempool->total,
               g_dnsparse_addr4_mempool->total - g_dnsparse_addr4_mempool->list.count,
                                                 g_dnsparse_addr4_mempool->size);
    printk("-------------------------------"IP_LF);
    printk("DNSPARSE_RR_MEMPOOL>"IP_LF);
    printk("TOTAL: %3d USED: %3d SIZE: %d"IP_LF, g_dnsparse_rr_mempool->total,
                  g_dnsparse_rr_mempool->total - g_dnsparse_rr_mempool->list.count,
                                                 g_dnsparse_rr_mempool->size);
}
#endif


IP_PUBLIC void
dnsparse_test_mctxDump(DNSPARSE_DNS_MESSAGE *pMsg, DNSPARSE_MCTXTYPE mctxType)
{
    struct list_head *pListNode = NULL;
    struct list_head *pListHead = NULL;
    int count  = 0;
    Ip_u8 *pData = NULL;
    int dumpSize = 0;


    if (mctxType == DNSPARSE_MCTXTYPE_NAME)
    {
        pListHead = &(pMsg->mctx.nameCtx);
        printk("======== NAMECTX  DUMP ========"IP_LF);
    }
    else
    {
        pListHead = &(pMsg->mctx.addr4Ctx);
        printk("======== ADDR4CTX DUMP ========"IP_LF);
    }

    /* print buffer info */
    list_for_each(pListNode, pListHead)
    {
        count++;
        printk(" No. : %d"IP_LF, count);
        pData = ((DNSPARSE_MCTX_COMMON*)pListNode)->memBlk.base;
        dumpSize = ((DNSPARSE_MCTX_COMMON*)pListNode)->memBlk.size;
        dnsparse_test_hexdump(pData, dumpSize);
    }
}

IP_PUBLIC void
dnsparse_test(void)
{
    dnsparse_result_t ret = DNSPARSE_SUCCESS;

    //dnsparse_test_poolStatus();

    ret = dnsparse_message_init(&testmsg);
    DNSPARSE_DEBUG("%s", _dnsparse_error_type2msg(ret));
    ret = dnsparse_message_parse(&testmsg, peer1_0, sizeof(peer1_0));
    DNSPARSE_DEBUG("%s", _dnsparse_error_type2msg(ret));

    dnsparse_test_mctxDump(&testmsg, DNSPARSE_MCTXTYPE_NAME);
    dnsparse_test_mctxDump(&testmsg, DNSPARSE_MCTXTYPE_ADDR4);

    printk("DNS Packet Info Dump:"IP_LF);
    printk("======== DNS Header   ========"IP_LF);
    printk("id          : 0x%4x"IP_LF, testmsg.id);
    printk("flags       : 0x%4x"IP_LF, testmsg.flags);
    printk("questions   :   %4d"IP_LF, testmsg.counts[DNSPARSE_DNS_SECTION_QUESTION]);
    printk("answers     :   %4d"IP_LF, testmsg.counts[DNSPARSE_DNS_SECTION_ANSWER]);
    printk("authorities :   %4d"IP_LF, testmsg.counts[DNSPARSE_DNS_SECTION_AUTHORITY]);
    printk("additional  :   %4d"IP_LF, testmsg.counts[DNSPARSE_DNS_SECTION_ADDITIONAL]);
    printk("======== DNS CONTENTS ========"IP_LF);
    dnsparse_test_printQuestion(&testmsg);
    dnsparse_test_printSection(&testmsg, DNSPARSE_DNS_SECTION_ANSWER);

    //dnsparse_test_poolStatus();
    dnsparse_message_destroy(&testmsg);
    //dnsparse_test_poolStatus();
}

/**************************************************************************************************/
/*                                      GLOBAL FUNCTIONS                                          */
/**************************************************************************************************/
